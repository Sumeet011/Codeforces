# Reversing a Subsequence for Minimal Sum: Problem Breakdown and Solution

## Problem Statement

You are given an integer sequence \( a_1, a_2, \dots, a_n \), and a segment \([l, r]\) such that \( 1 \leq l \leq r \leq n \).

You need to perform the following operation **exactly once** on the sequence:

1. Choose any subsequence of the sequence \( a \).
2. Reverse the chosen subsequence.

The task is to find the **minimum value of \( a_l + a_{l+1} + \dots + a_r \)** after performing the operation.

### Subsequence Definition

A subsequence is defined as:
- Choose any number of indices \( i_1, i_2, \dots, i_k \) such that \( 1 \leq i_1 < i_2 < \dots < i_k \leq n \).
- Reverse the values at these indices: the \( i_x \)-th element becomes the original value of the \( i_{k-x+1} \)-th element for all \( 1 \leq x \leq k \).

---

## C++ Solution

Here is the implementation of the solution in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    long long t;
    cin >> t; // Number of test cases

    while (t--) {
        long long n, l, r;
        cin >> n >> l >> r; // Length of array, and range [l, r]
        vector<long long> Left;
        vector<long long> Mid;
        vector<long long> Right;

        for (long long i = 0; i < n; ++i) {
            long long A;
            cin >> A;
            if (i < l - 1) {
                Left.push_back(A);
            } else if (i >= l - 1 && i < r) {
                Mid.push_back(A);
            } else {
                Right.push_back(A);
            }
        }

        sort(Left.begin(), Left.end());
        sort(Mid.begin(), Mid.end());
        sort(Right.begin(), Right.end());

        long long Ans = LLONG_MAX;

        // Calculate cost using Left and Mid
        long long c1 = 0;
        long long S1 = 0;
        long long L1 = 0;
        long long L2 = 0;
        while (S1 < r - l + 1) {
            if (L1 < Left.size() && (L2 >= Mid.size() || Left[L1] < Mid[L2])) {
                c1 += Left[L1];
                L1++;
            } else {
                c1 += Mid[L2];
                L2++;
            }
            S1++;
        }
        Ans = min(Ans, c1);

        // Calculate cost using Right and Mid
        long long c2 = 0;
        long long S2 = 0;
        L1 = 0;
        L2 = 0;
        while (S2 < r - l + 1) {
            if (L1 < Right.size() && (L2 >= Mid.size() || Right[L1] < Mid[L2])) {
                c2 += Right[L1];
                L1++;
            } else {
                c2 += Mid[L2];
                L2++;
            }
            S2++;
        }
        Ans = min(Ans, c2);

        cout << Ans << endl;
    }

    return 0;
}
